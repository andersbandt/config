//*****************************************************************************
//!
//! @file tests.c
//! @author Anders Bandt
//! @brief This file contains main function for WWD device
//! @version 0.9
//! @date April 2024
//!
//*****************************************************************************


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! -----------------------------------------------------------------------------------------------------------------------//
//! HEADER FILES ----------------------------------------------------------------------------------------------------------//
//! -----------------------------------------------------------------------------------------------------------------------//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Standard C99 stuff */
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/* My header files  */
#include <src/comm/comm.h>
#include <src/comm/i2c.h>
#include <src/comm/spi.h>
#include <src/comm/uart.h>
#include <src/power/power.h>
#include <src/hardware/led.h>
#include <src/ic/BQ25120A.h>
#include <src/ic/afe/AFE_HostControl.h>
#include <src/ic/imu/imu.h>
#include <src/data/nvs.h>



void test_actions(uart_comm_t * read_packet, Display_Handle display) {
    uart_write(read_packet->buffer, read_packet->bytes_read, display);
    uart_write("\n", 1, display);
    usleep(10000);

    /* flash-read */
    if (read_packet->buffer[0] == 'F' && read_packet->buffer[1] == 'R' && read_packet->buffer[2] == '9' && read_packet->buffer[3] == '1') {
    uart_write("FLASH-READ!\n", 12, display);
    uint8_t flash_read[1];
    char *flash_dump = (char *)malloc(10); // Allocate memory for 4 characters plus the null terminator
    for(int i = 0; i < 0x2000; i++) {
      nvs_read(flash_read, i, 1); // read 1 byte at a time
      /* sprintf(flash_dump, "%02X:%02X\n", i, flash_read[0]); */

      // print out flash bytes
      sprintf(flash_dump, "%X:%X\n", i, flash_read[0]);
      uart_write(flash_dump, strlen(flash_dump), display);

      // add some delay to server-side processing delay
      usleep(600);// 600 seems just perfect
    }
    }
    /* end function */

    /* flash-read-all */
    if (read_packet->buffer[0] == 'F' && read_packet->buffer[1] == 'R' && read_packet->buffer[2] == '0' && read_packet->buffer[3] == '1') {
        uart_write("FLASH-READ-ALL!\n", 16, display);
        uint8_t flash_read[1];
        char *flash_dump = (char *)malloc(10); // Allocate memory for 4 characters plus the null terminator
        size_t nvs_size = nvs_get_region_size();
        for(int i = 0; i < nvs_size; i++) {
          nvs_read(flash_read, i, 1); // read 1 byte at a time
          sprintf(flash_dump, "%X:%X\n", i, flash_read[0]);
          uart_write(flash_dump, strlen(flash_dump), display);
          usleep(1*1200);// need a longer delay here because the byte indices will get larger
        }
    }
    /* end function */

    /* flash-erase */
    if (read_packet->buffer[3] == '2' && read_packet->buffer[2] == '4' && read_packet->buffer[1] == 'E' && read_packet->buffer[0] == 'F') {
    uart_write("FLASH-ERASE!\n", 13, display);
    nvs_erase_region(display);
    uart_write("ERASE COMPLETE!\n", 16, display);
    }
    /* end function */


    /* imu_graph */
    if (read_packet->buffer[0] == '1' && read_packet->buffer[1] == '8' && read_packet->buffer[2] == 'P' && read_packet->buffer[3] == 'I') {
    uart_write("IMU-GRAPH!\n", 2, display);
    }
    /* end function */


    /* imu_graph */
    if (read_packet->buffer[3] == '1' && read_packet->buffer[2] == '8' && read_packet->buffer[1] == 'P' && read_packet->buffer[0] == 'I') {
    uart_write("IMU-GRAPH!\n", 2, display);
    }
    /* end function */

}
